---
title: 2018GDCPC-3
date: 2018-03-11 13:03:57
tags: 2018GDCPC
---

[比赛地址](https://vjudge.net/contest/215567)

总结：
- 题目好像出得偏难了一点
- Water_sheep应该是做过F题，所以开场就秒了，成功把board带歪了
- E实际上是一个很简单的数学＋递归求解的题目，由于都去做F了，直到最后一个半小时大家才醒悟过来。
- D定位是一个签到题目，明明可以暴力没想到这么多人直接算

A 简单题
- 题意：可以在空地上起蓝色和红色的房子，蓝色房子人口为100，红色房子人口为200。蓝色房子可以直接建，红色房子必须要建在蓝色房子旁边。房子可以拆掉，不影响红色房子。求可以最大人口时的建筑方案。
- 题解：很容易看到两个联通块之间没有关联，那么单独看每个联通块，通过不断建和拆最后肯定可以使得一个联通块里面只有一个蓝色房子，其余为红色房子。

B 中等偏难题
- 题解：给出一个DAG，找出有多少条多余的路。一条u到v的路认为是多余的当且仅当删掉这条路仍然可以间接从u走到v。
- 题解：最直接的做法是暴力dfs，对于每个点u，求u的所有儿子v可以访问到的点集记为S[u]，然后枚举u的每条出边(u,v),如果v属于S[u],既(u,v)是一条多余的路。
    这个做法是O(n^2)的，但是可以通过bitset来优化一下降低复杂度为O(n^2/64)。

C 难题
- 题意：给出一棵树，对于任意两个节点，定义f(u,v)为u到v路径上经过的边的权值的异或。
    回答q个询问[l,r]和m，有多少节点对满足f(u,v)>M,并且(l<=u<v<=r)
- 题解：
    由于异或的性质，可以得到f(u,v)=f(1,u)^(1,v)，利用这个性质转化成一个数组a[],a[i] = f(1,i).
    那么现在的问题实际上是求一个区间里面有多少对数满足异或大于M。
    先考虑一个简化的版本，给出一个数组，查询有多少个数异或给定的x大于一个定值M，这个可以通过trie来解决。
    对于区间的处理可以通过分块来解决。
    这个题目达到省赛的金牌题目的难度。

D 简单题
- 题解：定位为签到题，可以直接按照题目的要求来算出一个可行的答案。但是最简单是直接3个for枚举v1,v2,v3然后检查合法性

E 中等题
- 题意：给出一个函数f(n)的递归定义，问f(n)的第k个字符时什么。
- 题解：可以看到f的增长速度是指数级别的，实际上f(60)>1e18了，分类讨论n：
    - 定义`const string a = "What are you doing while sending \"";`
    - 当n大于60时，如果(n-60)\*a.length()已经大于k，那么ans＝a[(k-1)%a.length()]；否则，直接算f(60)第k-(n-60)*a.length()个字符
    - 当n小于等于60，直接暴力算f(n)的第k个字符
    每次查询复杂度是O(logk)
    这题由于查询q<=10，O(n)的做法也是可以通过。

F 难题
- 题意：给出一个n\*n的矩阵Cij(Cij非负)，求一个n\*n的01矩阵Xij满足：
    - X12+X13+...+X1N=1
    - X1N+X2N+...+XN-1=1
    - 对于所有i(1<i<n)，满足sigma(Xki)(1<=k<=n)=sigma(Xij)(1<=j<=n)
    时，使得sigma(Cij*Xij)最小。
- 题解：
    先把题目给的三个条件转化一下，对应为：
    - 1的出度为1
    - N的入度为1
    - 其他点的出入度相等
    这个时候比较容易想到实际Xij对应着一条从1到N的最路路。
    * 但是，还有另外一种情况满足上面的条件，就是从1出发经过某些点回到1，从n出发经过某些点回到n。*
    这两种情况组合一起才是上面的充分必要条件，求这两种情况的最小值即可。

G 中等题
- 题意：给出一个递增序列，求最长的子序列满足：
    - 元素是递增的
    - 任意相邻的两个元素不是互质的
- 题解：这题是lis的变种，所以很容易就想到dp的做法，但是朴素的dp复杂度是O(n^2\*logn)的，会TLE。
    观察到每个数最多只有6个不同的质因子: `2*3*5*7*11*13*17 > 1e5`
    那么，可以先预处理每个数的质因子，用质因子来表示状态，`dp[i][j]`表示考虑了i个数，并且最后一个数是质因子j的倍数的最长长度。
    转移:
    ```
    for (int i = 0; i < n; i++) {
        int tmp = 0
        for j in a[i]的质因子 {
            tmp = max(tmp, dp[i-1][j]);
        }
        for j in a[i]的质因子 {
            dp[i-1][j] = tmp + 1;
        }
        ans = max(ans, tmp + 1);
    }
    ```
    这个题也可以用因子来转移，每个数只有根号个因子。
